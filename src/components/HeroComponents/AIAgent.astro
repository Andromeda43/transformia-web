---
---

<div class="ai-agent-visualization">
  <!-- Agente inteligente que ocupa toda la pantalla -->
  <div class="agent-container">
    <!-- Visualización de zonas de decisión -->
    <div class="decision-zones"></div>
    
    <!-- Visualización de la ruta prevista -->
    <div class="planned-path-container" id="plannedPathContainer"></div>
    
    <!-- Avatar del agente -->
    <div class="agent-avatar" id="intelligentAgent">
      <div class="avatar-ring"></div>
      <div class="avatar-face">
        <div class="avatar-features">
          <div class="avatar-eyes">
            <div class="eye left"></div>
            <div class="eye right"></div>
          </div>
          <div class="avatar-smile"></div>
        </div>
      </div>
      
      <!-- Dirección del agente -->
      <div class="agent-direction" id="agentDirection"></div>
      
      <!-- Partículas que siguen al agente -->
      <div class="agent-particles">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
      </div>
    </div>
    
    <!-- Radar del agente -->
    <div class="agent-radar">
      <div class="radar-ring"></div>
      <div class="radar-ring"></div>
      <div class="radar-ring"></div>
      <div class="radar-sweep"></div>
    </div>
    
    <!-- Conexiones neuronales -->
    <div class="neural-connections-container" id="neuralConnections"></div>
    
    <!-- Elementos que el agente puede interactuar -->
    <div class="interaction-elements">
      <div class="interaction-node" data-type="data">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
          <polyline points="2 17 12 22 22 17"></polyline>
          <polyline points="2 12 12 17 22 12"></polyline>
        </svg>
      </div>
      
      <div class="interaction-node" data-type="processing">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      </div>
      
      <div class="interaction-node" data-type="analysis">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="3" y1="9" x2="21" y2="9"></line>
          <line x1="9" y1="21" x2="9" y2="9"></line>
        </svg>
      </div>
      
      <div class="interaction-node" data-type="output">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
        </svg>
      </div>
      
      <div class="interaction-node" data-type="learn">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 17l-2 2-2-2m4 0l2-2 2 2m-4 0V9"></path>
          <circle cx="12" cy="5" r="3"></circle>
        </svg>
      </div>
    </div>
  </div>
  
  <!-- Panel de métricas minimalista -->
  <div class="agent-metrics-panel">
    <div class="metrics-container">
      <div class="metric-item">
        <div class="metric-label">Procesamiento</div>
        <div class="metric-bar">
          <div class="metric-fill" id="processingMetric"></div>
        </div>
      </div>
      
      <div class="metric-item">
        <div class="metric-label">Confianza</div>
        <div class="metric-bar">
          <div class="metric-fill" id="confidenceMetric"></div>
        </div>
      </div>
      
      <div class="metric-item">
        <div class="metric-label">Tareas</div>
        <div class="metric-value" id="tasksMetric">3</div>
      </div>
      
      <div class="metric-item">
        <div class="metric-label">Estado</div>
        <div class="metric-status">
          <span class="status-indicator"></span>
          <span class="status-text">Activo</span>
        </div>
      </div>
    </div>
    
    <div class="agent-console">
      <div class="console-line"><span class="prompt">&gt;</span> <span id="consoleText1">Analizando datos</span></div>
      <div class="console-line"><span class="prompt">&gt;</span> <span id="consoleText2">Procesando respuesta</span></div>
      <div class="console-line"><span class="prompt">&gt;</span> <span id="consoleText3">Optimizando resultado</span></div>
    </div>
  </div>
</div>

<style>
  .ai-agent-visualization {
    background-color: rgba(20, 20, 35, 0.85);
    border-radius: 10px;
    border: 1px solid rgba(176, 66, 255, 0.5);
    overflow: hidden;
    box-shadow: 
      0 0 15px rgba(176, 66, 255, 0.3),
      0 0 30px rgba(176, 66, 255, 0.1);
    backdrop-filter: blur(10px);
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  /* Contenedor del agente */
  .agent-container {
    position: relative;
    height: 280px;
    flex-grow: 1;
    overflow: hidden;
    background: radial-gradient(circle at center, rgba(30, 30, 60, 0.5) 0%, rgba(15, 15, 30, 0.7) 100%);
  }
  
  /* Malla de cuadrícula para el entorno */
  .agent-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
      linear-gradient(to right, rgba(100, 100, 255, 0.1) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(100, 100, 255, 0.1) 1px, transparent 1px);
    background-size: 50px 50px;
    z-index: 1;
  }
  
  /* Puntos para el entorno que dan sensación de profundidad */
  .agent-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(rgba(176, 66, 255, 0.2) 1px, transparent 2px);
    background-size: 25px 25px;
    z-index: 1;
  }

  /* Avatar del agente */
  .agent-avatar {
    position: absolute;
    width: 80px;
    height: 80px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    cursor: pointer;
    transition: transform 0.3s ease-out;
  }
  
  /* Indicador de dirección del agente */
  .agent-direction {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 50%;
    left: 100%;
    transform: translateY(-50%);
    z-index: 11;
    pointer-events: none;
  }
  
  .agent-direction::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-left: 16px solid rgba(176, 66, 255, 0.7);
    transform-origin: left center;
    transform: rotate(0deg);
    left: 0;
    top: calc(50% - 8px);
  }
  
  /* Contenedor para la ruta planificada */
  .planned-path-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5;
    pointer-events: none;
  }
  
  /* Zonas de decisión del agente */
  .decision-zones {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    pointer-events: none;
  }

  .avatar-ring {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid rgba(176, 66, 255, 0.7);
    box-shadow: 0 0 15px rgba(176, 66, 255, 0.5);
    animation: rotate 10s linear infinite;
  }

  .avatar-ring::before {
    content: '';
    position: absolute;
    top: -5px;
    left: 50%;
    width: 10px;
    height: 10px;
    background-color: #b042ff;
    border-radius: 50%;
    transform: translateX(-50%);
  }

  .avatar-face {
    position: absolute;
    top: 10px;
    left: 10px;
    width: calc(100% - 20px);
    height: calc(100% - 20px);
    background: radial-gradient(circle, rgba(100, 200, 255, 0.3) 0%, rgba(176, 66, 255, 0.3) 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .avatar-features {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  .avatar-eyes {
    display: flex;
    gap: 10px;
    margin-bottom: 5px;
  }

  .eye {
    width: 8px;
    height: 8px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    animation: blink 3s infinite;
  }

  .avatar-smile {
    width: 20px;
    height: 10px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.9);
    border-radius: 50%;
  }

  /* Partículas que siguen al agente */
  .agent-particles {
    position: absolute;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background-color: rgba(176, 66, 255, 0.7);
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(176, 66, 255, 0.5);
    opacity: 0.8;
  }

  /* Radar alrededor del agente */
  .agent-radar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 300px;
    height: 300px;
    pointer-events: none;
    z-index: 1;
  }

  .radar-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    border: 1px solid rgba(176, 66, 255, 0.3);
  }

  .radar-ring:nth-child(1) {
    width: 100px;
    height: 100px;
    animation: pulse 3s infinite;
  }

  .radar-ring:nth-child(2) {
    width: 200px;
    height: 200px;
    animation: pulse 4s infinite;
  }

  .radar-ring:nth-child(3) {
    width: 300px;
    height: 300px;
    animation: pulse 5s infinite;
  }

  .radar-sweep {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 150px;
    height: 150px;
    transform-origin: center;
    animation: radar-sweep 5s linear infinite;
  }

  .radar-sweep::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 150px;
    height: 1px;
    background: linear-gradient(90deg, rgba(176, 66, 255, 0.7), transparent);
    transform-origin: left center;
  }

  /* Neural connections */
  .neural-connections-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 4;
    pointer-events: none;
  }
  
  /* Zonas de decisión */
  .decision-zone {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(100, 200, 255, 0.2) 0%, rgba(100, 200, 255, 0) 70%);
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 3;
    animation: pulse-zone 10s infinite ease-in-out;
  }
  
  @keyframes pulse-zone {
    0%, 100% {
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      transform: translate(-50%, -50%) scale(1.2);
    }
  }

  /* Interaction nodes */
  .interaction-elements {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 3;
  }

  .interaction-node {
    position: absolute;
    width: 40px;
    height: 40px;
    background-color: rgba(20, 20, 35, 0.7);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 10px rgba(176, 66, 255, 0.3);
    border: 1px solid rgba(176, 66, 255, 0.5);
    color: rgba(176, 66, 255, 0.8);
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .interaction-node[data-type="data"] {
    top: 15%;
    left: 15%;
  }

  .interaction-node[data-type="processing"] {
    top: 20%;
    right: 20%;
  }

  .interaction-node[data-type="analysis"] {
    bottom: 25%;
    left: 25%;
  }

  .interaction-node[data-type="output"] {
    bottom: 20%;
    right: 15%;
  }

  .interaction-node[data-type="learn"] {
    top: 50%;
    left: 80%;
  }

  .interaction-node:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(176, 66, 255, 0.7);
    color: rgba(176, 66, 255, 1);
  }
  
  .interaction-node.target-selected {
    transform: scale(1.2);
    box-shadow: 0 0 25px rgba(100, 255, 100, 0.9);
    color: rgba(100, 255, 100, 1);
    animation: pulse-target 1s infinite;
  }
  
  @keyframes pulse-target {
    0%, 100% {
      box-shadow: 0 0 15px rgba(100, 255, 100, 0.7);
    }
    50% {
      box-shadow: 0 0 25px rgba(100, 255, 100, 0.9);
    }
  }

  /* Panel de métricas minimalista */
  .agent-metrics-panel {
    background-color: rgba(15, 15, 25, 0.7);
    border-top: 1px solid rgba(176, 66, 255, 0.3);
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 70px;
  }

  .metrics-container {
    display: flex;
    gap: 15px;
    align-items: center;
  }

  .metric-item {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .metric-label {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.7);
  }

  .metric-bar {
    width: 100px;
    height: 4px;
    background-color: rgba(30, 30, 50, 0.5);
    border-radius: 2px;
    overflow: hidden;
  }

  .metric-fill {
    height: 100%;
    width: 75%;
    background: linear-gradient(90deg, #64c8ff, #b042ff);
    border-radius: 2px;
  }

  .metric-value {
    font-family: 'Space Mono', monospace;
    font-size: 0.9rem;
    font-weight: 700;
    color: #fff;
  }

  .metric-status {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    background-color: #4aef9e;
    border-radius: 50%;
    animation: pulse 1.5s infinite;
  }

  .status-text {
    font-family: 'Space Mono', monospace;
    font-size: 0.9rem;
    color: #4aef9e;
  }

  /* Agent console */
  .agent-console {
    font-family: 'Space Mono', monospace;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    width: 200px;
  }

  .console-line {
    display: flex;
    align-items: center;
    white-space: nowrap;
    overflow: hidden;
  }

  .prompt {
    color: #b042ff;
    margin-right: 5px;
  }

  /* Animaciones */
  @keyframes rotate {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  @keyframes blink {
    0%, 90%, 100% {
      transform: scale(1);
      opacity: 1;
    }
    95% {
      transform: scale(0.1);
      opacity: 0.1;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 0.5;
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      opacity: 0.2;
      transform: translate(-50%, -50%) scale(1.1);
    }
    100% {
      opacity: 0.5;
      transform: translate(-50%, -50%) scale(1);
    }
  }

  @keyframes radar-sweep {
    from {
      transform: translate(-50%, -50%) rotate(0deg);
    }
    to {
      transform: translate(-50%, -50%) rotate(360deg);
    }
  }

  /* Responsive */
  @media (max-width: 768px) {
    .agent-metrics-panel {
      flex-direction: column;
      height: auto;
      padding: 10px;
      gap: 10px;
    }
    
    .metrics-container {
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .metric-bar {
      width: 80px;
    }
    
    .agent-console {
      width: 100%;
      order: -1;
      margin-bottom: 10px;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Referencias a elementos DOM
    const intelligentAgent = document.getElementById('intelligentAgent');
    const agentDirection = document.getElementById('agentDirection');
    const neuralConnections = document.getElementById('neuralConnections');
    const plannedPathContainer = document.getElementById('plannedPathContainer');
    const interactionNodes = document.querySelectorAll('.interaction-node');
    const particles = document.querySelectorAll('.particle');
    
    const processingMetric = document.getElementById('processingMetric');
    const confidenceMetric = document.getElementById('confidenceMetric');
    const tasksMetric = document.getElementById('tasksMetric');
    
    const consoleText1 = document.getElementById('consoleText1');
    const consoleText2 = document.getElementById('consoleText2');
    const consoleText3 = document.getElementById('consoleText3');
    
    // Posiciones iniciales y variables para el movimiento
    let agentX = 50; // porcentaje
    let agentY = 50; // porcentaje
    let velocityX = 0;
    let velocityY = 0;
    let acceleration = 0.015; // Reducido para movimientos más suaves
    let maxVelocity = 0.4; // Reducido para evitar cambios bruscos
    let targetX = Math.random() * 80 + 10; // Mantener en un 80% central
    let targetY = Math.random() * 80 + 10;
    
    // Variables para movimiento de Bezier
    let waypoints: {x: number, y: number}[] = [];
    const maxWaypoints = 3; // Número de puntos de control para la curva
    let currentWaypointIndex = 0;
    let pathProgress = 0;
    let waypointReached = true;
    
    // Posiciones de los nodos de interacción para el agente
    const nodePositions: {x: number, y: number}[] = [];
    
    // Función para actualizar las partículas que siguen al agente
    function updateParticles() {
      if (!particles.length) return;
      
      particles.forEach((particle, index) => {
        const particleElement = particle as HTMLElement;
        const angle = (index / particles.length) * Math.PI * 2;
        
        // Radio variable con efecto suave
        const radius = 30 + Math.sin(Date.now() * 0.003 + index) * 10;
        
        // Añadir un componente de velocidad para que las partículas "sigan" al agente
        let trailFactor = 0;
        if (waypoints.length > 1 && currentWaypointIndex < waypoints.length - 1) {
          const startPoint = waypoints[currentWaypointIndex];
          const endPoint = waypoints[currentWaypointIndex + 1];
          const dx = endPoint.x - startPoint.x;
          const dy = endPoint.y - startPoint.y;
          const speed = Math.sqrt(dx * dx + dy * dy);
          
          // La estela es más pronunciada con mayor velocidad
          trailFactor = speed * 20;
        }
        
        // Calcular posición con efecto de estela
        const offsetX = Math.cos(angle + Date.now() * 0.001) * radius + trailFactor * Math.sin(angle);
        const offsetY = Math.sin(angle + Date.now() * 0.001) * radius - trailFactor * Math.cos(angle);
        
        particleElement.style.left = `calc(50% + ${offsetX}px)`;
        particleElement.style.top = `calc(50% + ${offsetY}px)`;
        particleElement.style.opacity = `${0.2 + Math.sin(Date.now() * 0.002 + index) * 0.3 + 0.5}`;
      });
    }
    
    // Función para crear las conexiones neuronales SVG
    function createNeuralConnections() {
      if (!neuralConnections) return;
      
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      
      // Verificación adicional de nulidad
      neuralConnections.appendChild(svg);
      
      // Almacenar las posiciones de los nodos
      interactionNodes.forEach(node => {
        const rect = node.getBoundingClientRect();
        // Verificación adicional de nulidad y uso de operador nullish coalescing
        const containerRect = neuralConnections?.getBoundingClientRect() ?? { 
          left: 0, 
          top: 0, 
          width: window.innerWidth, 
          height: window.innerHeight 
        };
        
        const x = (rect.left + rect.width / 2 - containerRect.left) / containerRect.width * 100;
        const y = (rect.top + rect.height / 2 - containerRect.top) / containerRect.height * 100;
        
        nodePositions.push({ x, y });
      });
      
      // Función para actualizar las conexiones con el agente
      function updateConnections() {
        // Limpiar conexiones anteriores
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
        
        // Asegurarse de que neuralConnections no sea null
        if (!neuralConnections) return;
        
        const containerWidth = neuralConnections.offsetWidth;
        const containerHeight = neuralConnections.offsetHeight;
        
        // Crear conexiones desde el agente a los nodos cercanos
        const agentCenterX = agentX * containerWidth / 100;
        const agentCenterY = agentY * containerHeight / 100;
        
        nodePositions.forEach((pos, index) => {
          const nodeX = pos.x * containerWidth / 100;
          const nodeY = pos.y * containerHeight / 100;
          
          // Calcular distancia
          const dx = nodeX - agentCenterX;
          const dy = nodeY - agentCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Solo conectar si está dentro de un rango
          if (distance < 300) {
            const opacity = 1 - distance / 300; // Más transparente cuanto más lejos
            
            // Línea de conexión
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', agentCenterX.toString());
            line.setAttribute('y1', agentCenterY.toString());
            line.setAttribute('x2', nodeX.toString());
            line.setAttribute('y2', nodeY.toString());
            line.setAttribute('stroke', `rgba(176, 66, 255, ${opacity * 0.7})`);
            line.setAttribute('stroke-width', '1');
            svg.appendChild(line);
            
            // Partícula de transmisión de datos
            if (Math.random() > 0.7) {
              const circle = document.createElementNS(svgNS, 'circle');
              circle.setAttribute('r', '3');
              circle.setAttribute('fill', '#ffffff');
              
              // Animación de la partícula
              const animateMotion = document.createElementNS(svgNS, 'animateMotion');
              animateMotion.setAttribute('path', `M${agentCenterX},${agentCenterY} L${nodeX},${nodeY}`);
              animateMotion.setAttribute('dur', `${Math.random() * 1.5 + 0.5}s`);
              animateMotion.setAttribute('repeatCount', '1');
              
              circle.appendChild(animateMotion);
              svg.appendChild(circle);
            }
          }
        });
      }
      
      // Actualizar conexiones periódicamente
      setInterval(updateConnections, 300);
    }
    
    // Función para generar puntos aleatorios de Bezier para movimiento suave
    function generateWaypoints(startX: number, startY: number, endX: number, endY: number) {
      const waypoints = [];
      
      // Siempre incluir el punto inicial
      waypoints.push({x: startX, y: startY});
      
      // Generar puntos de control intermedios
      for (let i = 0; i < maxWaypoints - 2; i++) {
        // Los puntos de control están a una distancia aleatoria del camino directo
        const t = (i + 1) / (maxWaypoints - 1); // Valor entre 0 y 1
        
        // Punto en la línea directa
        const lineX = startX + (endX - startX) * t;
        const lineY = startY + (endY - startY) * t;
        
        // Desviación perpendicular aleatoria (para crear curvas)
        const perpX = (endY - startY);
        const perpY = -(endX - startX);
        const length = Math.sqrt(perpX * perpX + perpY * perpY);
        
        // Desviación proporcional a la distancia total, pero aleatoria
        const deviation = ((Math.random() * 2) - 1) * Math.min(length * 0.3, 20);
        
        waypoints.push({
          x: lineX + (perpX / length) * deviation,
          y: lineY + (perpY / length) * deviation
        });
      }
      
      // Siempre incluir el punto final
      waypoints.push({x: endX, y: endY});
      
      return waypoints;
    }
    
    // Función para visualizar la ruta planificada del agente
    function visualizePlannedPath() {
      if (!plannedPathContainer) return;
      
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      
      plannedPathContainer.appendChild(svg);
      
      // Ruta principal hacia el objetivo
      const pathElement = document.createElementNS(svgNS, 'path');
      pathElement.setAttribute('fill', 'none');
      pathElement.setAttribute('stroke', 'rgba(176, 66, 255, 0.4)');
      pathElement.setAttribute('stroke-width', '2');
      pathElement.setAttribute('stroke-dasharray', '5,3');
      
      // Historial de posiciones para mostrar el rastro
      const positionHistory: {x: number, y: number}[] = [];
      const maxHistoryLength = 20;
      
      // Actualizar la visualización de la ruta
      function updatePath() {
        if (!plannedPathContainer) return;
        
        const containerWidth = plannedPathContainer.offsetWidth;
        const containerHeight = plannedPathContainer.offsetHeight;
        
        // Posición actual del agente
        const agentPosX = agentX * containerWidth / 100;
        const agentPosY = agentY * containerHeight / 100;
        
        // Posición del objetivo
        const targetPosX = targetX * containerWidth / 100;
        const targetPosY = targetY * containerHeight / 100;
        
        // Añadir posición actual al historial
        positionHistory.push({ x: agentPosX, y: agentPosY });
        
        // Limitar el tamaño del historial
        if (positionHistory.length > maxHistoryLength) {
          positionHistory.shift();
        }
        
        // Construir la ruta del rastro
        if (positionHistory.length > 1) {
          const trailPath = document.createElementNS(svgNS, 'path');
          let pathData = `M ${positionHistory[0].x} ${positionHistory[0].y}`;
          
          for (let i = 1; i < positionHistory.length; i++) {
            pathData += ` L ${positionHistory[i].x} ${positionHistory[i].y}`;
          }
          
          trailPath.setAttribute('d', pathData);
          trailPath.setAttribute('fill', 'none');
          trailPath.setAttribute('stroke', 'rgba(100, 200, 255, 0.4)');
          trailPath.setAttribute('stroke-width', '2');
          
          // Limpiar SVG anterior
          while (svg.firstChild) {
            svg.removeChild(svg.firstChild);
          }
          
          // Añadir rastro
          svg.appendChild(trailPath);
          
          // Añadir línea punteada hacia el objetivo
          if (targetPosX !== agentPosX || targetPosY !== agentPosY) {
            // Visualizar la ruta de Bezier si tenemos waypoints
            if (waypoints.length > 1) {
              let bezierPath = `M ${agentPosX} ${agentPosY}`;
              
              // Convertir waypoints a coordenadas de píxeles
              const waypointsPixels = waypoints.map(wp => ({
                x: wp.x * containerWidth / 100,
                y: wp.y * containerHeight / 100
              }));
              
              // Añadir los puntos restantes como una curva
              for (let i = 1; i < waypointsPixels.length; i++) {
                bezierPath += ` L ${waypointsPixels[i].x} ${waypointsPixels[i].y}`;
              }
              
              pathElement.setAttribute('d', bezierPath);
            } else {
              // Línea recta al objetivo si no hay waypoints
              pathElement.setAttribute('d', `M ${agentPosX} ${agentPosY} L ${targetPosX} ${targetPosY}`);
            }
            svg.appendChild(pathElement);
          }
        }
      }
      
      // Actualizar periódicamente
      setInterval(updatePath, 100);
    }
    
    // Función para calcular posición en curva Bezier
    function bezierPoint(points: {x: number, y: number}[], t: number) {
      if (points.length === 1) {
        return points[0];
      }
      
      const newPoints = [];
      for (let i = 0; i < points.length - 1; i++) {
        newPoints.push({
          x: points[i].x * (1 - t) + points[i + 1].x * t,
          y: points[i].y * (1 - t) + points[i + 1].y * t
        });
      }
      
      return bezierPoint(newPoints, t);
    }
    
    // Función para animar el movimiento del agente
    function animateAgent() {
      if (!intelligentAgent || !agentDirection) return;
      
      function updatePosition() {
        // Si necesitamos generar nuevos waypoints
        if (waypointReached) {
          // Generar nuevo conjunto de waypoints para movimiento suave
          waypoints = generateWaypoints(agentX, agentY, targetX, targetY);
          pathProgress = 0;
          currentWaypointIndex = 0;
          waypointReached = false;
        }
        
        // Avanzar a través de la curva Bezier
        pathProgress += 0.01; // Velocidad de movimiento a lo largo de la curva
        
        if (pathProgress >= 1) {
          // Si estamos en el último waypoint, hemos llegado al destino
          if (currentWaypointIndex >= waypoints.length - 2) {
            // Generar nuevo objetivo aleatorio dentro del contenedor
            targetX = Math.random() * 80 + 10;
            targetY = Math.random() * 80 + 10;
            waypointReached = true;
          } else {
            // Moverse al siguiente segmento de waypoint
            currentWaypointIndex++;
            pathProgress = 0;
          }
        }
        
        // Si tenemos waypoints, seguir la curva Bezier
        if (waypoints.length > 1) {
          // Calcular posición actual en la curva entre los waypoints actuales
          const startPoint = waypoints[currentWaypointIndex];
          const endPoint = waypoints[currentWaypointIndex + 1];
          
          // Interpolación
          agentX = startPoint.x + (endPoint.x - startPoint.x) * pathProgress;
          agentY = startPoint.y + (endPoint.y - startPoint.y) * pathProgress;
          
          // Calcular dirección de movimiento
          const dx = endPoint.x - startPoint.x;
          const dy = endPoint.y - startPoint.y;
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          
          // Actualizar dirección visual
          const agentDirectionElement = agentDirection as HTMLElement;
          agentDirectionElement.style.transform = `translateY(-50%) rotate(${angle}deg)`;
          
          // La flecha es más visible cuando hay velocidad
          const speed = Math.sqrt(dx * dx + dy * dy);
          agentDirectionElement.style.opacity = Math.min(1, speed * 10).toString();
        }
        
        // Aplicar el movimiento al elemento DOM del agente
        const agentElement = intelligentAgent as HTMLElement;
        agentElement.style.left = `${agentX}%`;
        agentElement.style.top = `${agentY}%`;
        
        // Animar las partículas para que sigan al agente
        updateParticles();
        
        // Continuar la animación
        requestAnimationFrame(updatePosition);
      }
      
      // Iniciar la animación
      updatePosition();
    }
    
    // Función para animar las métricas
    function animateMetrics() {
      if (!processingMetric || !confidenceMetric || !tasksMetric) return;
      
      // Valores de referencia
      let processing = 85;
      let confidence = 92;
      let tasks = 3;
      
      // Actualizar periódicamente
      setInterval(() => {
        // Generar variaciones aleatorias
        processing += (Math.random() - 0.5) * 10;
        processing = Math.max(60, Math.min(98, processing));
        
        confidence += (Math.random() - 0.5) * 8;
        confidence = Math.max(70, Math.min(99, confidence));
        
        // Ocasionalmente cambiar el número de tareas
        if (Math.random() < 0.1) {
          tasks = Math.floor(Math.random() * 5) + 1;
        }
        
        // Actualizar DOM
        const processingElement = processingMetric as HTMLElement;
        const confidenceElement = confidenceMetric as HTMLElement;
        
        processingElement.style.width = `${processing}%`;
        confidenceElement.style.width = `${confidence}%`;
        
        if (tasksMetric) {
          tasksMetric.textContent = tasks.toString();
        }
      }, 3000);
    }
    
    // Función para animar el texto de la consola
    function animateConsole() {
      const messages = [
        'Analizando datos',
        'Procesando respuesta',
        'Optimizando resultado',
        'Evaluando opciones',
        'Aplicando aprendizaje',
        'Generando predicciones',
        'Conectando sistemas',
        'Mejorando precisión',
        'Priorizando acciones',
        'Actualizando modelos'
      ];
      
      setInterval(() => {
        if (consoleText1 && consoleText2 && consoleText3) {
          // Desplazar mensajes
          consoleText1.textContent = consoleText2.textContent;
          consoleText2.textContent = consoleText3.textContent;
          
          // Generar nuevo mensaje
          const randomIndex = Math.floor(Math.random() * messages.length);
          consoleText3.textContent = messages[randomIndex];
        }
      }, 4000);
    }
    
    // Visualizar zonas de decisión (heatmap)
    function createDecisionZones() {
      const decisionZones = document.querySelector('.decision-zones');
      if (!decisionZones) return;
      
      // Crear zonas con probabilidades de decisión
      for (let i = 0; i < 10; i++) {
        const zone = document.createElement('div');
        zone.className = 'decision-zone';
        
        // Posición aleatoria
        const zoneX = Math.random() * 80 + 10;
        const zoneY = Math.random() * 80 + 10;
        
        // Tamaño aleatorio
        const zoneSize = Math.random() * 100 + 50;
        
        // Intensidad aleatoria (influencia en la decisión)
        const intensity = Math.random() * 0.7 + 0.1;
        
        zone.style.left = `${zoneX}%`;
        zone.style.top = `${zoneY}%`;
        zone.style.width = `${zoneSize}px`;
        zone.style.height = `${zoneSize}px`;
        zone.style.opacity = intensity.toString();
        
        decisionZones.appendChild(zone);
      }
    }
    
    // Inicializar todas las animaciones
    function initialize() {
      createNeuralConnections();
      visualizePlannedPath();
      createDecisionZones();
      animateAgent();
      animateMetrics();
      animateConsole();
      
      // Añadir interactividad a los nodos
      interactionNodes.forEach(node => {
        node.addEventListener('click', () => {
          // Hacer que el agente se mueva hacia el nodo clickeado
          const rect = node.getBoundingClientRect();
          const container = document.querySelector('.agent-container');
          
          if (container) {
            const containerRect = container.getBoundingClientRect();
            
            // Convertir coordenadas a porcentajes
            targetX = ((rect.left + rect.width / 2) - containerRect.left) / containerRect.width * 100;
            targetY = ((rect.top + rect.height / 2) - containerRect.top) / containerRect.height * 100;
            
            // Forzar regeneración de waypoints para crear un nuevo camino curvo
            waypointReached = true;
            
            // Mostrar feedback visual de que se ha seleccionado este nodo
            node.classList.add('target-selected');
            setTimeout(() => {
              node.classList.remove('target-selected');
            }, 2000);
            
            // Actualizar consola para mostrar que se dirige al objetivo
            if (consoleText3) {
              consoleText3.textContent = "Dirigiéndose al objetivo seleccionado";
            }
          }
        });
      });
    }
    
    // Iniciar cuando el DOM esté cargado
    setTimeout(initialize, 500);
  });